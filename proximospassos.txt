

## ğŸ§­ Regra de ouro do roadmap

**Primeiro garantimos o â€œpipeline mÃ­nimo confiÃ¡velâ€**: ingestÃ£o â†’ dedup â†’ persistÃªncia â†’ observabilidade â†’ deploy.
SÃ³ depois: escala (mais concelhos), automaÃ§Ã£o, notificaÃ§Ãµes, dashboard â€œbonitoâ€.

---

## âœ… Fase 2 â€” UserSavedProgram (favoritos)

**Objetivo:** o utilizador guarda apoios e volta depois. Isso aumenta retenÃ§Ã£o e valida o produto *mesmo antes do scraping ficar perfeito*.

### EntregÃ¡veis

* **Tabela/modelo** `UserSavedProgram` (userId, programId, createdAt)
* API:

  * `POST /api/saved-programs` (guardar)
  * `DELETE /api/saved-programs/:id` (remover)
  * `GET /api/saved-programs` (listar do user)
* UI:

  * BotÃ£o â€œGuardarâ€ no detalhe/lista
  * PÃ¡gina `/conta/favoritos` (ou dentro do `/conta/dossier`)

### DependÃªncias

* NextAuth funcional e RLS/policies no Supabase (ou equivalente via Prisma + server-side auth).

---

## âš™ï¸ Fase 3 â€” Workers/Scrapers (ingestÃ£o real)

**Objetivo:** sair de mock data e ter 1 pipeline real (Cascais + Fundo Ambiental), com dedup e logs.

### 3.1. Definir â€œcontrato de dadosâ€ (antes do scraping)

Isto evita refactors dolorosos.

* **Programa** (mÃ­nimo):

  * `source` (ex: `municipality:cascais`, `national:fundo-ambiental`)
  * `title`, `description`, `url`
  * `municipalityId` (ou null para nacional)
  * `eligibilityTags` (opcional jÃ¡)
  * `startsAt`, `endsAt` (quando existir)
  * `contentHash` âœ…
  * `slug` (derivado e estÃ¡vel)
  * `rawHtml`/`rawText` (opcional mas ajuda para debug e reprocess)

### 3.2. Dedup por `contentHash` (como fazer sem dramas)

* Canonicaliza conteÃºdo antes do hash:

  * remover espaÃ§os repetidos, scripts, ids randÃ³micos, timestamps Ã³bvios
* `contentHash = sha256(canonicalText + canonicalUrl + source)`
* PolÃ­tica:

  * se `contentHash` jÃ¡ existe â†’ skip update
  * se `slug` existe mas hash mudou â†’ criar â€œnova versÃ£oâ€ **ou** atualizar e guardar `updatedAt` + histÃ³rico (decide jÃ¡)

### 3.3. Scraper Cascais (piloto municipal)

**EntregÃ¡veis**

* `workers/cascais.ts` (ou `src/workers/...`)
* Seletores reais (CSS/DOM)
* NormalizaÃ§Ã£o + mapping para o teu modelo
* **Retry + rate limit**

  * retry com backoff exponencial (ex: 3 tentativas)
  * rate limit (ex: 1 req/seg) para nÃ£o virar vilÃ£o

### 3.4. Worker Fundo Ambiental (piloto nacional)

Mesmo pipeline, outra fonte.

### 3.5. Logs estruturados

**Sem logs bons, scraping Ã© sofrimento.**
Formato recomendado (JSON):

* `runId`, `source`, `step`, `url`, `status`, `durationMs`, `itemsFound`, `itemsInserted`, `itemsUpdated`, `itemsSkipped`, `error`

PersistÃªncia:

* tabela `ingestion_runs`
* tabela `ingestion_events` (opcional) ou sÃ³ `runs` + `error_blob`

---

## ğŸš€ Fase 4 â€” Deploy Staging (Vercel + Supabase)

**Objetivo:** staging â€œrealâ€, com pipeline a correr, e checks mÃ­nimos.

### 4.1. Setup de ambientes

* Vercel env vars: DB URL, NextAuth secret, providers, etc.
* Supabase: RLS policies para dados do user
* Separar `staging` vs `prod` (projetos Supabase diferentes, idealmente)

### 4.2. ExecuÃ§Ã£o dos workers

Escolhe 1 (nÃ£o faÃ§as as duas coisas ao mesmo tempo):

**OpÃ§Ã£o A â€” Vercel Cron (bom para MVP)**

* Endpoint protegido tipo `POST /api/ingest/run` com secret header
* Cron diÃ¡rio (ou 2x/dia)

**OpÃ§Ã£o B â€” GitHub Actions (mais previsÃ­vel/observÃ¡vel)**

* Corre um script Node que chama o pipeline
* Logs ficam no Actions + podes notificar falhas

ğŸ‘‰ Eu faria: **Vercel Cron no inÃ­cio**, GitHub Actions quando a coisa estiver sensÃ­vel/complexa.

### 4.3. Testes E2E bÃ¡sicos

SÃ³ o mÃ­nimo que evita regressÃµes idiotas:

* login
* listar apoios
* abrir detalhe
* guardar favorito
* ver favoritos

---

## ğŸ”” NotificaÃ§Ãµes de novos programas

**Objetivo:** quando entra algo novo, alertar utilizadores (por concelho + perfil).

### Passos

1. **Regra de deteÃ§Ã£o â€œnovoâ€**

   * novo `programId` inserido **ou** hash mudou (se decides â€œupdateâ€ como novidade)
2. **PreferÃªncias do utilizador**

   * `user_notification_settings`: concelhos seguidos + tags (opcional)
3. **Fila de notificaÃ§Ãµes**

   * tabela `notification_queue` com status (`pending/sent/failed`)
4. **Email provider** (Brevo, Resend, etc.)
5. **Batch sender** (cron separado)

---

## ğŸ“Š Dashboard de monitorizaÃ§Ã£o

**Objetivo:** veres ingestÃ£o e falhas sem SSH + grep.

### MVP do dashboard (nÃ£o inventar BI)

* PÃ¡gina admin protegida:

  * Ãºltimos `ingestion_runs`
  * success rate
  * top errors (agrupados)
  * â€œitems inserted/updated/skippedâ€ por source

Depois, se fizer sentido:

* grÃ¡fico de ingestÃ£o por dia
* alertas (email/discord) quando falha

---

## ğŸ—ºï¸ Expandir para mais concelhos (Sintra, Oeiras, Lisboaâ€¦)

Isto sÃ³ escala bem se definires uma **arquitetura de â€œadaptersâ€**:

* `sources/municipality/<name>.ts`

  * `discoverUrls()`
  * `parseListPage()`
  * `parseDetailPage()`
* tudo despeja no mesmo `normalizeProgram()` â†’ `upsertProgram()`

**Ordem sugerida**

1. Oeiras (normalmente sites mais organizados)
2. Sintra
3. Lisboa (tende a ser mais â€œenterprise chaosâ€)

---

## ğŸ§± Roadmap por sprints (prÃ¡tico)

### Sprint 1 (fundaÃ§Ã£o)

* UserSavedProgram (API + UI)
* `ingestion_runs` + logs estruturados
* pipeline `upsert + contentHash`

### Sprint 2 (primeiro scraping real)

* Worker Fundo Ambiental
* Worker Cascais
* dedup a funcionar e mÃ©tricas bÃ¡sicas

### Sprint 3 (staging + automaÃ§Ã£o)

* Vercel staging + Supabase staging
* Cron (Vercel ou GH Actions)
* E2E mÃ­nimo

### Sprint 4 (retention loop)

* notificaÃ§Ãµes (settings + queue + batch sender)
* dashboard admin v1

### Sprint 5 (escala)

* 2â€“3 concelhos novos com adapters
* hardening (rate limit, retries, alertas)

---

## ğŸ‘Š DecisÃ£o tÃ©cnica que te poupa semanas

Define jÃ¡ se vais tratar mudanÃ§as como:

* **Update in-place** (mais simples, perde histÃ³rico)
* **Versionado** (mais complexo, mas perfeito para â€œnovo apoio/alteraÃ§Ã£oâ€)

Para notificaÃ§Ãµes, **versionado** Ã© ouro. Para MVP rÃ¡pido, **update in-place** chega.

workers
Tabela ponto de situaÃ§Ã£o das candidaturas a beneficiÃ¡rios aos apoios (consultar tabelas se existirem)
ex: https://www.fundoambiental.pt/plataforma-vales-de-eficiencia/beneficiarios-situacao-das-candidaturas.aspx
ex: https://www.fundoambiental.pt/plataforma-vales-de-eficiencia/situacao-das-candidaturas.aspx
ex: https://www.fundoambiental.pt/plataforma-vales-de-eficiencia/candidaturas-a-medidas-situacao-das-candidaturas.aspx